use anyhow::Result;
use sea_query::{Iden, PostgresQueryBuilder, Query};
use sea_query_binder::SqlxBinder;
use sqlb::HasFields;
use sqlx::{PgPool, Pool, Postgres};

#[tokio::main]
async fn main() -> Result<()> {
	let db = init_db().await?;

	let todo_1 = TodoForCreate {
		title: "todo 01 title".to_string(),
		..Default::default()
	};

	// region:    --- Insert

	// -- Get the data from struct (with sqlb unzip() for sea-query insert)
	let (columns, values) = todo_1.not_none_fields().unzip();

	// -- Build the insert query (sea-query)
	let (sql, values) = Query::insert()
		.into_table(TodoSpec::Table)
		.columns(columns)
		.values(values)?
		.returning(Query::returning().columns([TodoSpec::Id]))
		.build_sqlx(PostgresQueryBuilder);

	// -- Execute the query (sqlx)
	let query = sqlx::query_as_with::<_, (i64,), _>(&sql, values);
	let (todo_1_id,) = query.fetch_one(&db).await?;

	// -- Debug prints
	println!("Todo created - id: {todo_1_id}");

	// endregion: --- Insert

	// region:    --- Update

	let todo_1_update = TodoForCreate {
		done: Some(true),
		..Default::default()
	};

	// -- Get the data from struct (with sqlb zip() for sea-query update)
	let name_value_iterator = todo_1_update.not_none_fields().zip();

	// -- Build the update query (sea-query)
	let (sql, values) = Query::update()
		.table(TodoSpec::Table)
		.values(name_value_iterator)
		.build_sqlx(PostgresQueryBuilder);

	// -- Exec the query
	let query = sqlx::query_with(&sql, values);
	let rows_changed = query.execute(&db).await?.rows_affected();
	println!("Todo updated. Row affected {rows_changed}");

	// endregion: --- Update

	// region:    --- Select
	// -- Get the column idenfiers for Todo (sqlb)
	let columns = Todo::field_idens();

	// -- Build the insert query (sea-query)
	let (sql, values) = Query::select()
		.from(TodoSpec::Table)
		.columns(columns)
		.build_sqlx(PostgresQueryBuilder);

	// -- Execute the query (sqlx)
	let todos = sqlx::query_as_with::<_, Todo, _>(&sql, values).fetch_all(&db).await?;

	// -- Debug print.
	println!("Select todos:");
	for todo in todos {
		println!("   {todo:?}");
	}

	// endregion: --- Select

	Ok(())
}

// region:    --- Todo
#[derive(Iden)]
enum TodoSpec {
	#[iden(rename = "todo")]
	Table,
	Id,
}

#[derive(sqlb::Fields, Debug, Default)]
struct TodoForCreate {
	title: String,
	done: Option<bool>, // if None, not set, so db default (false)
	#[field(name = "description")]
	desc: Option<String>, // if None, not set, so db default (false)
}

#[derive(sqlb::Fields, Debug, Default)]
struct TodoForUpdate {
	title: Option<String>,
	done: Option<bool>,
	#[field(name = "description")]
	desc: Option<String>,
}

#[derive(sqlb::Fields, sqlx::FromRow, Debug)]
struct Todo {
	id: i64,
	title: String,
	done: bool,

	// Note: Both are needed.
	//       field(...) from sqlb, for the Todo::field_idens().
	//       sqlx(...) from sqlx, for the select to Todo.
	#[field(name = "description")]
	#[sqlx(rename = "description")]
	desc: Option<String>,
}
// endregion: --- Todo

// region:    --- SQL Init
const SQL: [&str; 2] = [
	r#"
DROP TABLE IF EXISTS "todo""#,
	r#"
CREATE TABLE "todo" (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1000) PRIMARY KEY,

  title varchar(128) NOT NULL,
	done bool NOT NULL DEFAULT false,
	description varchar(256)
);"#,
];
async fn init_db() -> Result<Pool<Postgres>> {
	let db = PgPool::connect("postgres://postgres:welcome@localhost/postgres").await.unwrap();
	// let mut con = connection.try_acquire().unwrap();
	for sql in SQL {
		sqlx::query(sql).execute(&db).await?;
	}

	Ok(db)
}
// endregion: --- SQL Init
