use anyhow::Result;
use deadpool_postgres::{ManagerConfig, Pool, RecyclingMethod, Runtime};
use sea_query::{Iden, PostgresQueryBuilder, Query};
use sea_query_postgres::PostgresBinder;
use sqlb::HasFields;
use std::convert::TryFrom;
use tokio_postgres::{NoTls, Row};

#[tokio::main]
async fn main() -> Result<()> {
	let db = init_db().await?;

	let todo_1 = TodoForCreate {
		title: "todo 01 title".to_string(),
		..Default::default()
	};

	// region:    --- Insert

	// -- Get Fields, then, sea-query columns/values from sqlb.
	let (columns, values) = todo_1.not_none_fields().unzip();

	// -- Build the query with sea-query and the postgres binding.
	let (sql, values) = Query::insert()
		.into_table(TodoSpec::Table)
		.columns(columns)
		.values(values)?
		.build_postgres(PostgresQueryBuilder);

	// -- Execute the query (tokio-postgres)
	let client = db.get().await?;
	let rows_changed = client.execute(sql.as_str(), &values.as_params()).await?;

	// -- Debug print.
	println!("Todo created - Row affected {rows_changed:?}");

	// endregion: --- Insert

	// region:    --- Update

	let todo_1_update = TodoForCreate {
		done: Some(true),
		..Default::default()
	};

	// -- Get the data from struct (with sqlb zip() for sea-query update)
	let name_value_iterator = todo_1_update.not_none_fields().zip();

	// -- Build the update query (sea-query)
	let (sql, values) = Query::update()
		.table(TodoSpec::Table)
		.values(name_value_iterator)
		.build_postgres(PostgresQueryBuilder);

	// -- Execute the query (tokio-postgres)
	let client = db.get().await?;
	let rows_changed = client.execute(sql.as_str(), &values.as_params()).await?;
	println!("Todo updated - Row affected {rows_changed}");

	// endregion: --- Update

	// region:    --- Select

	// -- Get the columns for the Todo type.
	let columns = Todo::field_idens();

	// -- Build the query
	let (sql, values) = Query::select()
		.from(TodoSpec::Table)
		.columns(columns)
		.build_postgres(PostgresQueryBuilder);

	// -- Execute the query.
	let client = db.get().await?;
	let rows = client.query(&sql, &values.as_params()).await?;
	let todos = rows.into_iter().map(Todo::try_from).collect::<Result<Vec<Todo>>>()?;

	// -- Debug print.
	println!("Select todos:");
	for todo in todos {
		println!("   {todo:?}");
	}

	// endregion: --- Select

	Ok(())
}

// region:    --- Todo
#[derive(Iden)]
enum TodoSpec {
	#[iden(rename = "todo")]
	Table,
}

#[derive(sqlb::Fields, Debug, Default)]
struct TodoForCreate {
	title: String,
	done: Option<bool>, // if None, not set, so db default (false)
	#[field(name = "description")]
	desc: Option<String>, // if None, not set, so db default (false)
}

#[derive(sqlb::Fields, Debug, Default)]
struct TodoForUpdate {
	title: Option<String>,
	done: Option<bool>,
	#[field(name = "description")]
	desc: Option<String>,
}

#[derive(sqlb::Fields, Debug)]
struct Todo {
	id: i64,
	title: String,
	done: bool,
	#[field(name = "description")]
	desc: Option<String>,
}

impl TryFrom<Row> for Todo {
	type Error = anyhow::Error;
	fn try_from(row: Row) -> Result<Todo> {
		Ok(Todo {
			id: row.try_get("id")?,
			title: row.try_get("title")?,
			done: row.try_get("done")?,
			desc: row.try_get("description")?,
		})
	}
}
// endregion: --- Todo

// region:    --- Init Db
const SQL: [&str; 2] = [
	r#"
DROP TABLE IF EXISTS "todo""#,
	r#"
CREATE TABLE "todo" (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1000) PRIMARY KEY,

  title varchar(128) NOT NULL,
	done bool NOT NULL DEFAULT false,
	description varchar(256)
);"#,
];

async fn init_db() -> Result<Pool> {
	let pool = get_db_pool()?;

	let client = pool.get().await?;
	for sql in SQL {
		client.simple_query(sql).await?;
	}

	Ok(pool)
}

fn get_db_pool() -> Result<Pool> {
	// -- Create config
	let mut config = deadpool_postgres::Config::new();
	config.user = Some("postgres".to_string());
	config.password = Some("welcome".to_string());
	config.dbname = Some("postgres".to_string());
	config.host = Some("localhost".to_string());
	config.manager = Some(ManagerConfig {
		recycling_method: RecyclingMethod::Fast,
	});

	Ok(config.create_pool(Some(Runtime::Tokio1), NoTls)?)
}

// endregion: --- Init Db
